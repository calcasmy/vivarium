# vivarium/deploy/src/data_loader/pgdump_data_loader.py
import os, sys
import subprocess
import getpass
from typing import Optional, Tuple

# Ensure the vivarium root path is in sys.path
# Three levels up to vivarium root: database/ -> src/ -> deploy/ -> vivarium/
# if __name__ == "__main__":
#     vivarium_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', '..'))
#     if vivarium_path not in sys.path:
#         sys.path.insert(0, vivarium_path)

from utilities.src.logger import LogHelper
from utilities.src.new_config import DatabaseConfig, FileConfig
from utilities.src.db_operations import DBOperations, ConnectionDetails

from deploy.src.data_loader.data_loader_strategy import DataLoaderStrategy

logger = LogHelper.get_logger(__name__)

class PGDumpDataLoader(DataLoaderStrategy):
    """
    Concrete pgdump data loading strategy for ingesting data into a PostgreSQL database
    from a plain SQL dump file, typically generated by pg_dump.
    
    This class utilizes the `psql` command-line utility to restore the dump.
    It implements the :class:`~.DataLoaderStrategy` abstract interface.
    """
    def __init__(self, file_path: Optional[str],
                 db_config: Optional[DatabaseConfig] = None):
        """
        Initializes the PGDumpDataLoader strategy.
        Loads database configuration and initializes DatabaseOperations.

        :param file_path: The absolute path to the PostgreSQL dump file (`.sql`) to be loaded.
                          If `None`, the loader will not attempt to load a dump unless
                          explicitly configured otherwise.
        :type file_path: Optional[str]
        :param db_config: An optional :class:`~.DatabaseConfig` object containing
                          database connection parameters (host, port, user, password, dbname).
                          If `None`, a new default :class:`~.DatabaseConfig` instance will be created.
        :type db_config: Optional[DatabaseConfig]
        """
        super().__init__()
        self.file_path = file_path
        self.db_config = db_config if db_config else DatabaseConfig()
        self.app_conn_details = self.db_config.postgres_remote_connection \
                                if self.db_config._is_remote_db else self.db_config.postgres_local_connection
        
        # PGDumpDataLoader uses subprocess to call psql, so it doesn't manage
        # a direct psycopg2 connection itself.
        logger.info("PGDumpDataLoader: Initialized for PostgreSQL data loading.")

    def load_from_dump(self) -> bool:
        """
        Loads data into the PostgreSQL database from the dump file specified during
        initialization (`self.file_path`). This method uses the 'psql' command-line utility.

        The database password for the application user (`self.db_config.user`)
        must be available in `self.db_config.password`. It is used via the
        `PGPASSWORD` environment variable for non-interactive `psql` execution.

        :returns: :obj:`True` if the dump is successfully restored, :obj:`False` otherwise.
        :rtype: bool
        :raises FileNotFoundError: If the 'psql' command is not found in the system's PATH.
        :raises ValueError: If no dump file path is provided or if the application
                            user's password is not available in `db_config`.
        :raises Exception: For any other unexpected errors during the dump loading process.

        .. note::
           This method relies on the `psql` client being installed and accessible
           in the environment's PATH where this script is executed.
        """
        if not self.file_path:
            logger.error("PGDumpDataLoader: No dump file path provided during initialization to load from.")
            return False

        if not os.path.exists(self.file_path)or not os.path.isfile(self.file_path):
            logger.error(f"PGDumpDataLoader: Dump file not found at: {self.file_path}.")
            return False

        logger.info(f"PGDumpDataLoader: Loading data from dump file: {self.file_path}")

        # Construct connection string for psql
        db_user = self.app_conn_details.user
        db_name = self.app_conn_details.dbname
        db_host = self.app_conn_details.host
        db_port = str(self.app_conn_details.port)

        # Using PGPASSWORD environment variable for non-interactive psql
        app_password = self.app_conn_details.password
        if not app_password:
            logger.error(
                f"PGDumpDataLoader: Application user password not found in configuration for user '{db_user}'. "
                "Cannot proceed with non-interactive psql dump loading. "
                "Please set 'APP_DB_PASSWORD' in your 'config_secrets.ini' or similar secure configuration."
            )
            # Raise an error to stop execution immediately in automated environments
            raise ValueError("Application database password is required for dump loading via psql.")

        logger.info(f"PGDumpDataLoader: Attempting to load data from dump file: '{self.file_path}' into database '{db_name}'.")

        # Temporarily set PGPASSWORD environment variable for psql
        env_with_password = os.environ.copy()
        env_with_password['PGPASSWORD'] = app_password

        # psql command to restore a plain SQL dump
        command = [
            'psql',
            '-h', db_host,
            '-p', db_port,
            '-U', db_user,
            '-d', db_name,
            '-f', self.file_path, # Read commands from file
            '-v', 'ON_ERROR_STOP=1' # Stop on first error
        ]

        logger.info(f"PGDumpDataLoader: Executing psql command:" 
                    f"{' '.join(command[:-1])} < {os.path.basename(self.file_path)}")
        
        try:
            # Use subprocess.run for cleaner handling and error checking
            process = subprocess.run(
                command,
                capture_output=True,  # Capture stdout and stderr
                text=True,            # Decode stdout/stderr as text
                check=False,          # Do not raise CalledProcessError automatically
                env=env_with_password # Pass the environment with PGPASSWORD
            )

            if process.returncode != 0:
                logger.error(f"PGDumpDataLoader: Failed to load dump file '{self.file_path}'. "
                             f"Psql exited with code {process.returncode}.")
                logger.error(f"PSQL STDOUT:\n{process.stdout.strip()}")
                logger.error(f"PSQL STDERR:\n{process.stderr.strip()}")
                return False
            else:
                logger.info(f"PGDumpDataLoader: Successfully loaded data from dump file '{self.file_path}'.")
                # Log psql output at debug level if it exists, even on success
                if process.stdout.strip():
                    logger.debug(f"PSQL STDOUT (success):\n{process.stdout.strip()}")
                if process.stderr.strip():
                    logger.debug(f"PSQL STDERR (success):\n{process.stderr.strip()}")
                return True
        except FileNotFoundError:
            logger.critical("PGDumpDataLoader: 'psql' command not found. "
                            "Ensure PostgreSQL client tools are installed and in your system's PATH.")
            raise # Re-raise to indicate a critical setup error
        except Exception as e:
            logger.error(f"PGDumpDataLoader: An unexpected error occurred during dump loading: {e}", exc_info=True)
            return False
        finally:
            # PGPASSWORD should be removed from the environment after the subprocess call
            # Note: This only affects the current process's environment; child processes get a copy.
            if 'PGPASSWORD' in env_with_password: # Check the dictionary used for the subprocess
                # No direct del os.environ['PGPASSWORD'] needed here as we used a copy (env_with_password)
                # If os.environ was directly modified, it would be del os.environ['PGPASSWORD']
                pass # The PGPASSWORD is only set in the sub-process's environment copy, so no cleanup needed in parent os.environ

    def load_json_data(self) -> bool:
        """
        PGDumpDataLoader does not support loading raw JSON data directly.
        This method will log a warning and return False.

        :returns: False, as this operation is not supported by this loader.
        :rtype: bool
        """
        logger.warning("PGDumpDataLoader: 'load_json_data' is not supported by this loader strategy. Please use JSONDataLoader for this purpose.")
        return False

    def execute_full_data_load(self) -> bool:
        """
        Orchestrates the full data loading process for PostgreSQL, primarily
        by loading data from the dump file specified during initialization.

        :returns: :obj:`True` if the dump file is successfully loaded, :obj:`False` otherwise.
        :rtype: bool
        """
        logger.info("PGDumpDataLoader: Starting full data loading process.")
        load_success = False
        try:
            if self.file_path:
                logger.info(f"PGDumpDataLoader: Initiating dump file load from '{self.file_path}'.")
                load_success = self.load_from_dump()
            else:
                logger.info("PGDumpDataLoader: No dump file path provided during initialization. Skipping dump load.")
                load_success = True # Consider it successful if nothing was to load

            if load_success:
                logger.info("PGDumpDataLoader: Full data loading process completed successfully.")
            else:
                logger.error("PGDumpDataLoader: Full data loading process finished with errors.")
            
            return load_success
        except Exception as e:
            logger.error(f"PGDumpDataLoader: An unexpected error occurred during full data loading: {e}", exc_info=True)
            return False